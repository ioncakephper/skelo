#!/usr/bin/env node

const Commander = require("commander");
const {globSync} = require("glob");
const path = require("path");
const yamljs = require("yamljs");
const fs = require("fs");
const Handlebars = require("handlebars");

const {isValidOutlineFile, normalizeItem, slugify} = require('../index');

const program = new Commander.Command();

let {version = "1.0.0", name = "skelo", description = "Build sidebars and topic files for Docusaurus-powered sites."} = require("../package.json");
program
    .version(version)
    .description(description)
    .name(name)
    
program
    .command("build [args...]", {isDefault: true})
    .description("Build sidebars and topic files for Docusaurus-powered sites.")
    .option("-d, --docs <path>", "Path to your Docusaurus docs folder.", "docs")
    .option('-s, --sidebarsName <name>', 'Name of your sidebars file.', 'sidebars')
    .option('--sidebarsExtension <extension>', 'Extension of your sidebars file.', 'js')
    .option('--templatesPath <path>', 'Path to your Docusaurus templates folder.', 'templates')
    .option('--templatesExtension <extension>', 'Extension of your templates file.', 'hbs')
    .option('--topicExtension <extension>', 'Extension of your topic file.', 'md')
    .option('-v, --verbose', 'Verbose output.')
    .action((args, options) => {
        console.log("Building sidebars and topic files for Docusaurus-powered sites.");
        // console.log(JSON.stringify(options, null, 2));
        // console.log(JSON.stringify(args, null, 2));

        let outlineFiles = getOutlineFiles(args, options);
        // console.log(JSON.stringify(outlineFiles, null, 2));

        documentSidebars = {};

        outlineFiles.forEach((outlineFile) => {

            let content = yamljs.load(outlineFile);
            let contentOptions = {...content, ...{parentPath: ''}};
            // let contentOptions = buildOptions(options, buildOptions(content, {parentPath: ''}));
          
            // contentOptions = buildOptions(contentOptions, {parentPath: ''});
            options = {...options, ...contentOptions, ...buildOptions(contentOptions, {parentPath: ''})};
            delete contentOptions.sidebars;
            delete contentOptions.path;

            content.sidebars.forEach((sidebarDefinition) => {
                // console.log(JSON.stringify(sidebarDefinition, null, 2));
                sidebarDefinition = normalizeItem(sidebarDefinition);
                let {sidebarLabel, sidebarItems} = {
                    
                        sidebarLabel: sidebarDefinition.label, //sidebarDefinition.slug || slugify(sidebarDefinition.label),
                        sidebarItems: (sidebarDefinition.autogenerated && typeof sidebarDefinition.autogenerated === 'boolean') ? [buildAutogenerated(sidebarDefinition, {...options, ...contentOptions})] : buildItems(sidebarDefinition.items, buildOptions(sidebarDefinition, options)), //buildItems(sidebarDefinition.items, options)
                    
                };

                documentSidebars[sidebarLabel] = sidebarItems;
            })
        });

        // generate sidebars files
        let sidebarsFilename = path.join(`${options.sidebarsName}.${options.sidebarsExtension}`);
        let sidebarsContent = renderTemplateFile('sidebars', {sidebars: JSON.stringify(documentSidebars, null, 2)}, options);

        fs.writeFileSync(sidebarsFilename, sidebarsContent, 'utf8');
        logProgress(`Created sidebar file: ${sidebarsFilename}`, options);
    });

// program.parse(process.argv);
program.parse("node bin/cli.js build --verbose --docs website-docs/docs --sidebarsName website-docs/sidebars --sidebarsExtension js --templatesPath templates".split(" "))

function buildOptions(item, options) {
    let parentPath = path.join(
        `${options.parentPath || ''}`,
        `${item.path || ``}`
    );
    parentPath = parentPath.replace(/\\/g, '/');

    return {...options, ...{parentPath}};
    // return {...options, ...item, ...{parentPath}};

}

function buildAutogenerated(item, options) {

    // let localpath = (item.path || '').split('/').map(slugify).join('/');
    let parentPath = (options.parentPath || '').split('/').map(slugify).join('/');
    let localPath = (item.path || '').split('/').map(slugify).join('/');
    let basename = path.join(parentPath, localPath);
    return {
        type: "autogenerated",
        dirName: basename || '.'
    }
}


/**
 * Renders a Handlebars template string with the provided data and returns the result.
 *
 * @param {string} templateString - The Handlebars template string to render.
 * @param {Object} data - The data to be used for rendering the template string.
 * @throws {Error} Throws an error if the template string or data is missing.
 * @return {string} The rendered result of the Handlebars template string.
 */
function render(templateString, data) {
    // Check if both templateString and data are provided
    if (!templateString || !data) {
        throw new Error('Template string and data are required');
    }

    // Compile the template string with data and return the result
    return Handlebars.compile(templateString)(data);
}

/**
 * Renders a Handlebars template file with the provided data and returns the result.
 *
 * @param {string} templateFilename - The filename of the Handlebars template file to render.
 * @param {Object} data - The data to be used for rendering the template file.
 * @param {Object} options - Additional options for rendering the template file.
 * @param {string} options.templatesPath - The path to the templates folder.
 * @param {string} options.templateExtension - The extension of the template file.
 * @throws {Error} Throws an error if any of the required parameters are missing or if the template file does not exist.
 * @return {string} The rendered result of the Handlebars template file.
 */
function renderTemplateFile(templateFilename, data, options) {
    // Check if all required parameters are provided
    if (!templateFilename || !data || !options || !options.templatesPath || !options.templatesExtension) {
        throw new Error('Template filename, data, options, templatesPath, and templatesExtension are required');
    }

    // Add the template extension if it is not already present
    templateFilename = path.extname(templateFilename) === '' ? `${templateFilename}.${options.templatesExtension}` : templateFilename;
    // Join the templatesPath with the templateFilename to get the full path to the template file
    templateFilename = path.join(options.templatesPath, templateFilename);

    try {
        // Read the template file and render it with the provided data
        return render(fs.readFileSync(templateFilename, 'utf8'), data);
    } catch (err) {
        // If the template file does not exist, throw an error
        if (err.code === 'ENOENT') {
            throw new Error(`Template file ${templateFilename} does not exist`);
        } else {
            // Otherwise, throw the original error
            throw err;
        }
    }
}

/**
 * Creates a topic file based on the provided item and options.
 * 
 * @param {Object} item - The item containing information about the topic.
 * @param {Object} options - Additional options for creating the topic file.
 * @param {string} options.parentPath - The path to the parent directory.
 * @param {string} options.docs - The path to the docs folder.
 * @param {string} options.topicExtension - The extension of the topic file.
 * @throws {Error} Throws an error if there is an issue creating the topic file.
 * @return {string} The path of the created topic file.
 */
function createTopic(item, options) {

    // Generate a slugified basename for the topic
    let basename = slugify(item.slug || item.label);
    // Split and map the local path to slugify each part
    let localpath = (item.path || '').split('/').map(slugify).join('/');

    // Generate a parent path based on the options and slugify each part
    let parentPath = (options.parentPath || '').split('/').filter(e => !/^\.+$/.test(e)).map(slugify).join('/');
    // Combine parentPath, localpath, and basename to get the full path
    basename = path.join(parentPath, localpath, basename);

    try {
        // Define the full topic filename with the appropriate extension
        let topicFilename = path.join(options.docs, `${basename}`);
        topicFilename = path.extname(topicFilename) === '' ? `${topicFilename}.${options.topicExtension}` : topicFilename;

        // Render the topic content using a template and build the necessary variables
        let topicContent = renderTemplateFile('topic', buildTopicVariables(item, options), options);
        
        // Create the directory if it doesn't exist
        const pathPart = path.dirname(topicFilename);
        if (!fs.existsSync(pathPart)) {
            try {
                fs.mkdirSync(pathPart, { recursive: true });
            } catch (err) {
                console.error(`Error creating directory ${pathPart}: ${err}`);
                throw err;
            }
        }
        
        // Write the topic content to the topic file
        fs.writeFileSync(topicFilename, topicContent, 'utf8');
        // Log progress after creating the topic file
        logProgress(`Created topic file: ${topicFilename}`, options);
    } catch (err) {
        console.error(err);
        throw err;
    }
    
    return basename.replace(/\\/g, '/');
}


/**
 * Logs a progress message if verbose mode is enabled in the options.
 *
 * @param {string} message - The progress message to log.
 * @param {Object} options - The options object containing the verbose mode flag.
 */
function logProgress(message, options) {
    // If options or verbose is not provided, return early.
    if (!options || typeof options.verbose === 'undefined') {
        return;
    }

    // If verbose mode is enabled, log the progress message.
    if (options.verbose) {
        // Log the progress message.
        console.log(message);
    }
}



/**
 * Builds topic variables for rendering a topic file.
 * @param {object} item - The item to build topic variables for.
 * @param {object} options - The options for building the topic variables.
 * @returns {object} The built topic variables.
 */
function buildTopicVariables(item, options) {
    if (item.headings) {
        item.headings = orderItems({items: item.headings}, options)
    }
    // Build topic variables by spreading the item object,
    // adding hasSlug and hasId properties, and adding itemHeadings.
    return {
        ...item, 
        // Check if the item has a slug and add hasSlug property.
        ...{hasSlug: item.slug ? true : false},
        // Check if the item has an id and add hasId property.
        ...{hasId: item.id ? true : false},
        // Build topic headings with a level of 2 and add itemHeadings property.
        ...{itemHeadings: buildTopicHeadings(item.headings, 2, options)},
    };
}

/**
 * Builds topic headings for rendering a topic file.
 * @param {Array<object>} headings - The list of headings to be built.
 * @param {number} level - The level of the headings.
 * @param {object} options - The options for building the topic headings.
 * @returns {string} The built topic headings.
 */
function buildTopicHeadings(headings = [], level = 2, options) {
    // Map each heading to its rendered representation and join them by a newline character.
    return headings.map(heading => {
        // Render the heading template with the provided heading object,
        // add the prefix property with the corresponding number of '#' characters,
        // and add itemHeadings property with the built topic headings of the items.
        heading.items = orderItems(heading, options)
        return renderTemplateFile('heading', {
            ...heading,
            ...{prefix: '#'.repeat(level)},
            ...{itemHeadings: buildTopicHeadings(heading.items, level + 1, options)}
        }, options)

    }).join('\n');
}

/**
 * Retrieves the list of outline files based on the provided arguments and options.
 *
 * @param {Array<string>} args - The list of arguments to be used for filtering the outline files.
 * @param {Object} options - The options to be used for filtering the outline files.
 * @return {Array<string>} - The list of valid outline files.
 */
function getOutlineFiles(args, options) {

    args = args.length === 0 ? ['__outlines__/**/*.outline.yaml', '**/*.outline.yaml'] : args;
    args = args.map(filename => (path.extname(filename) === '' ? `${filename}.outline.yaml` : filename));

    let filenames = globSync(args);
    return filenames.filter(filename => isValidOutlineFile(filename, options));
}

/**
 * Builds the items for the sidebar based on the provided items and options.
 *
 * @param {Array<object>} items - The list of items to be built.
 * @param {Object} options - The options to be used for building the items.
 * @return {Array<object>} - The list of built items.
 */
function buildItems(items, options) {
    return items.map(item => {
        // If the item has sub-items, recursively build the items and return a category object.
        if (item.items && item.items.length > 0) {
            item.items = orderItems(item, options);
            return {
                label: item.label,
                type: "category",
                items: buildItems(item.items, buildOptions(item, options)),
                // Add generated index information if specified.
                ...buildGeneratedIndex(item, options)
            }
        } else {
            // If the item is an autogenerated item, return an object with autogenerated information.
            if (item.autogenerated && typeof item.autogenerated === 'boolean') {
                return buildAutogenerated(item, buildOptions(item, options));
            }
            // If the item has an href, return a link object.
            if (item.href) {
                return {
                    label: item.label,
                    type: "link",
                    href: item.href,
                    description: item.description,
                    className: item.className,
                }
            }
            // If none of the above conditions are met, create a topic object.
            return createTopic(item, options);
        }
    })
}

/**
 * Orders items based on the order property.
 *
 * @param {object} item - The item to order.
 * @param {object} options - The options to be used for ordering the item.
 * @returns {Array<object>} - The ordered items.
 */
function orderItems(item, options) {

    // If the item has an order property and it is a boolean value, set it to an object with default values
    if (item.order && typeof item.order === 'boolean' && item.order === true) {
        item.order = {
            by: 'label',
            direction: 'asc'
        }
    }
    // If the item has an order property and it is an object, replace it with an object that has default values plus the values from the item order property
    if (item.order && typeof item.order === 'object') {
        item.order = {
            ...{
                by: 'label',
                direction: 'asc'
            },
            ...item.order
        }
    }

    // If the item has an order property and it is an object, sort the items based on that property
    if (item.order && typeof item.order === 'object') {
        return item.items.sort((a, b) => {
            if (a[item.order.by] < b[item.order.by]) {
                return item.order.direction === 'asc' ? -1 : 1;
            }
            if (a[item.order.by] > b[item.order.by]) {
                return item.order.direction === 'asc' ? 1 : -1;
            }
            return 0;
        });
    }

    // If the item does not have an order property, return the items as is
    return item.items
}


/**
 * Builds the generated index object for an item if it has the property `generatedIndex` or `options.autoGeneratedIndex` is true.
 * 
 * @param {object} item - The item to build the generated index for.
 * @param {object} options - The options for building the generated index.
 * @returns {object} - The generated index object if `generatedIndex` or `options.autoGeneratedIndex` is true, otherwise an empty object.
 */
function buildGeneratedIndex(item, options) {
    // Check if the item has the property `generatedIndex` or `options.autoGeneratedIndex` is true
    if (item.generatedIndex || options.autoGeneratedIndex) {
        
        // Return the generated index object
        return {
            /**
             * The link object for the generated index.
             * @type {object}
             */
            "link": {
                /**
                 * The type of the link.
                 * @type {string}
                 */
                "type": "generated-index",
                // /**
                //  * The label for the generated index link.
                //  * @type {string}
                //  */
                // "label": "Generated Index",
                /**
                 * The title for the generated index link.
                 * @type {string}
                 */
                "title": item.title || item.label,
                // /**
                //  * The description for the generated index link.
                //  * @type {string}
                //  */
                // "description": item.description || '',
                // /**
                //  * The keywords for the generated index link.
                //  * @type {Array<string>}
                //  */
                // "keywords": item.keywords || [],
                // /**
                //  * The image for the generated index link.
                //  * @type {string}
                //  */
                // "image": item.image || '',
            }
        }
    }
    // Return an empty object if `generatedIndex` or `options.autoGeneratedIndex` is not true
    return {}
}





