const { isNull, isUndefined, isEmpty, isString, isBoolean } = require("lodash");
const { slug, saveDocument } = require('file-easy')
const hbsr = require("hbsr");

/**
 * Build a category object based on the provided item and options.
 * @param {Object} item - The item to build the category from.
 * @param {Object} options - The options to customize the category.
 * @returns {Object} - The built category object.
 */
function buildCategory(item, options) {
    // Build the basic category object
    let result = {
        type: 'category',
        label: item.label,
        items: buildItems(item.items, {
            ...options,
            ...getItemOptions(item, options)
        }),
    }

    // Add link for generated index if applicable
    if (isGeneratedIndex(item)) {
        result['link'] = {
            type: 'generated-index',
            title: item.label
        }
    }

    // Add link for custom index if applicable
    let { index } = item;
    if (index) {
        let indexBasename = getSluggedPath([options.path, item.path, slug(index.slug || index.id || index.label)]);
        createTopicDocument(index, indexBasename, options)
        result['link'] = {
            type: 'doc',
            id: slug(index.slug || index.id || index.label),
        }
    }

    return result;
}

/**
 * Builds headings for a given list of items.
 * @param {Array} items - The list of items to build headings for.
 * @param {number} level - The heading level.
 * @returns {string} - The constructed headings as a string.
 */
function buildHeadings(items = [], level = 2) {
    // Map through the items and build headings for each item
    return items.map(item => {
        // Render the heading template with item details and nested headings
        return hbsr.render_template('heading', {
            ...item,
            ...{
                prefix: '#'.repeat(level),
                itemHeadings: buildHeadings(item.items, level + 1)
            }
        })
    }).join('\n'); // Join the built headings with a new line
}

/**
 * Build items based on their type (topic or category)
 * @param {Array} items - The items to be built
 * @param {Object} options - The options for building the items
 * @returns {Array} - The built items
 */
function buildItems(items, options) {
    return items.map(item => {
        if (isTopic(item) && isAutoGenerated(item)) {
            return {
                type: 'autogenerated',
                dirName: (item.path) ? item.path : '.'
            }
        }
        if (isTopic(item) && isLink(item)) {
            return {
                type: 'link',
                label: item.label,
                href: item.href
            }
        }
        if (isTopic(item) && !isLink(item)) {
            return buildTopic(item, options);
        }
        return buildCategory(item, options);
    })
}

/**
 * Builds a topic based on the provided item and options.
 * @param {Object} item - The item to build the topic from.
 * @param {Object} options - The options for building the topic.
 * @returns {string} - The basename of the built topic.
 */
function buildTopic(item, options) {
    // Generate the slug for the item
    let theSlug = slug(item.slug || item.id || item.label);
    // Get the slugged path for the item
    let itemBasename = getSluggedPath([options.path, item.path, theSlug]);
    // Create the topic document
    createTopicDocument(item, itemBasename, options);

    return itemBasename;
}

/**
 * Create a topic document with the given item and options
 * @param {Object} item - The item to be included in the document
 * @param {string} itemBasename - The base name for the item
 * @param {Object} options - Additional options for creating the document
 */
function createTopicDocument(item, itemBasename, options) {
    // Render the template with the item and the built headings
    let fileContent = hbsr.render_template('topic', {
        ...item,
        ...{
            itemHeadings: buildHeadings(item.headings)
        }
    });

    // Generate the filename based on the slugged path and item basename
    let filename = `${getSluggedPath(options.docs)}/${itemBasename}.md`;

    // Save the document with the generated filename and file content
    saveDocument(filename, fileContent);
    logMessage(options.verbose, `[INFO] created topic file: ${filename}`);
}

/**
 * Get item options based on the sidebar and options.
 * 
 * Concatenate options.path and sidebar.path and return the slugged path
 * ignoring empty and undefined values.
 * @param {Object} sidebar - The sidebar object.
 * @param {Object} options - The options object.
 * @returns {Object} - The item options object.
 * @example <caption>Options has no path property</caption>
 * const options = {};
 * const sidebar = {
 *    path: 'item path / subpath '
 * }
 * const itemOptions = getItemOptions(sidebar, options);
 * console.log(itemOptions.path);
 * // => itemOptions.path = "item-path/subpath"
 * 
 * @example <caption>With path options</caption>
 * const options = {
 *    path: 'parent path '
 * };
 * const sidebar = {
 *    path: 'item path / subpath '
 * }
 * const itemOptions = getItemOptions(sidebar, options);
 * console.log(itemOptions.path);
 * // => itemOptions.path = "parent-path/item-path/subpath"
 *
 */
function getItemOptions(sidebar, options) {
    // Get the slugged path for options and sidebar
    const parts = [
        getSluggedPath(options.path),
        getSluggedPath(sidebar.path)
    ];

    // Return the item options with the slugged path
    return {
        path: getSluggedPath(parts)
    };
}

/**
 * Check if the item is auto-generated.
 * @param {Object} item - The item to be checked.
 * @returns {boolean} - True if the item is auto-generated, false otherwise.
 */
function isAutoGenerated(item) {
    return isTrue(item.autogenerated);
}

/**
 * Check if the item has a generated index.
 * 
 * @param {Object} item - The item to check.
 * @returns {boolean} - True if the item has a generated index, false otherwise.
 */
function isGeneratedIndex(item) {
    return isTrue(item.generated_index);
}

/**
 * Check if the given item is a link.
 * @param {Object} item - The item to be checked.
 * @returns {boolean} - True if the item is a link, false otherwise.
 */
function isLink(item) {
    // Check if the item has a non-empty href property
    return (item.href) && !isEmpty(item.href.trim());
}

/**
 * Check if the given item is a topic.
 * @param {object} item - The item to be checked.
 * @returns {boolean} - True if the item is a topic, false otherwise.
 */
function isTopic(item) {
    return item.items.length === 0;
}

/**
 * Check if the input value is considered true.
 *
 * @param {any} value - the value to be checked
 * @return {boolean} true if the value is considered true, false otherwise
 */
function isTrue(value) {
    if (isString(value)) {
        return value.trim().toLowerCase() === 'true';
    }
    if (isBoolean(value)) {
        return value;
    }
    return false;
}

/**
 * Logs the message if the verbose flag is true
 * 
 * @param {boolean} verbose - Flag to determine if the message should be logged
 * @param {string} message - The message to be logged
 */
function logMessage(verbose, message) {
    if (verbose) {
        console.log(message);
    }
}

/**
 * Normalize the given item to ensure it has a label and its sub-items are also normalized
 * @param {Object|String} item - The item to be normalized
 * @returns {Object} - The normalized item
 */
function normalizeItem(item) {
    // If the item is a string, transform it into an object with a label property
    if (typeof item === 'string') {
        return normalizeItem({ label: item });
    }

    // If the item is an object and has a label property
    if (typeof item === 'object' && item.label) {
        // Merge the item with a default items array to avoid undefined errors
        item = {
            ...{ items: [] },
            ...item
        };

        // Destructure the items, headings, and index properties from the item
        const { items, headings, index } = item;
        // If items exist, normalize each item in the array
        if (items) {
            item.items = items.map(normalizeItem);
        }
        // If the items array is empty and headings exist, normalize each heading
        if (item.items.length === 0 && headings) {
            item.headings = headings.map(normalizeItem);
        }
        // If index exists, normalize it
        if (index) {
            item.index = normalizeItem(index);
        }
    }

    // If the item is an object without a label property
    if (typeof item === 'object' && !item.label) {
        // Get the label and items from the item object
        const label = Object.keys(item)[0];
        const items = item[label];

        // Normalize the item with label and items properties
        return normalizeItem({ label, items });
    }

    // Return the normalized item
    return item;
}

/**
 * Generates a slugged path from a string
 * @param {string|Array.<string>} s - The input string
 * @returns {string} - The slugged path
 */
function getSluggedPath(s = '') {
    // If the input is a string, split it and call getSluggedPath recursively
    if (typeof s === 'string') {
        return getSluggedPath(s.split('/'));
    }

    // Filter out empty, null, and undefined elements, then slug and join the array
    return s.filter(e => !isEmpty(e) && !isNull(e) && !isUndefined(e)).map(e => slug(e)).join('/');
}

module.exports = {
    buildCategory,
    buildHeadings,
    buildItems,
    buildTopic,
    createTopicDocument,
    getItemOptions,
    isAutoGenerated,
    isGeneratedIndex,
    isLink,
    isTopic,
    isTrue,
    logMessage,
    normalizeItem,
}