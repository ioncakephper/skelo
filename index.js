/*
 * Created on Sat Jun 10 2023
 *
 * Copyright (c) 2023 Your Company
 */

const program = require('commander')
const { isString, isObject, isArray, isEmpty } = require('lodash');
const { render } = require('hbsr')
const path = require('path');
const { saveDocument, setDefaultExtension, slug } = require('file-easy');
const fs = require('fs');
const yamljs = require('yamljs');

'use strict';

let { name, version, description } = require('./package.json');

program
    .name(name)
    .version(version)
    .description(description)

program
    .command('build', { isDefault: true })
    .description('build topic files and sidebar layout file from outline files')
    .argument('[outlineFile...]', 'file with sidebar outline', `${name}.outline`)

    .option('-d, --docs <path>', 'path to Docusaurus documents root folder', 'docs')
    .option('-s, --sidebar <filename>', '', 'sidebars.js')
    .option('--sidebarExtension <extension>', 'default extension for sidebar file', '.js')
    .option('--outlineExtension <extension>', 'default extension for outline file', '.yml')
    .option('--topicExtension <extension>', 'default extension for topic file', '.md')
    .action((outlineFile, options) => {
        // ensure outline files are in an array
        // Set the file to be used for the outline file.
        if (isString(outlineFile)) {
            outlineFile = [outlineFile]
        }

        // append default outline extension; add default extension to files ending with '.outline'
        outlineFile = outlineFile.map(fn => {
            // outline extension is the outline extension
            if (fn.endsWith('.outline')) {
                return `${fn}${options.outlineExtension}`
            }
            return setDefaultExtension(fn, options.outlineExtension)})


        let documentationSidebars = {}
        outlineFile.forEach(singleOutlineFile => {
            getSidebarDefinitions(singleOutlineFile).forEach(sidebarDefinition => {
                // console.log(JSON.stringify(sidebarDefinition))

                let { label, items, autogenerated } = sidebarDefinition;
                // Adds the documentation sidebar to the documentation sidebar.
                if (autogenerated === true) {
                    documentationSidebars[label] = [{ type: "autogenerated", dirName: sidebarDefinition.path || '.' }]
                } else {
                    documentationSidebars[label] = buildSidebarItems(items, { ...options, ...{ parentPath: getSluggedPath(sidebarDefinition.path || '.') } })
                }
            })
        })


        let content = JSON.stringify(documentationSidebars, null, 4)

        let template = `module.exports = {{{content}}}`
        let sidebarsContent = render(template, { content })

        let sidebarFilename = path.join(options.sidebar);
        sidebarFilename = setDefaultExtension(sidebarFilename, options.sidebarExtension)
        saveDocument(sidebarFilename, sidebarsContent);
    })

program.parse()


/**
* Gets the sidebars defined in a single - outliner file. This is a helper function for getSidebarDefinitions.
* 
* @param singleOutlineFilename - The name of the file to read.
* 
* @return { Array } A list of sidebar definitions in the file or an empty array if the file is not a yaml
*/
function getSidebarDefinitions(singleOutlineFilename) {

    let parts = path.basename(singleOutlineFilename).split('.');
    let ext = parts.pop()
    let isYaml = ["yml", "yaml"].includes(ext.toLowerCase())

    // Returns a list of sidebar definitions.
    if (isYaml) {

        let sidebarDefinitions = yamljs.load(singleOutlineFilename).sidebars;
        return sidebarDefinitions.map(item => normalizeItem(item))
    }
}


/**
* Builds the sidebar items. This is the main function that handles the creation of the sidebars items.
* 
* @param items - The items to be displayed on the sidebar.
* @param options - The options to be used when building the items.
* 
* @return { Array } The items that should be displayed on the sidebar in the form of { topic : {... }
*/
function buildSidebarItems(items, options) {
    items = items.map(item => normalizeItem(item))

    return items.map(item => {
        item = normalizeItem(item);

        let isALink = Object.keys(item).includes('href');
        // Returns the link to the current item.
        if (isALink) {
            return buildALink(item, options)
        }
        return isTopic(item)
            ? buildTopic(item, options)
            : buildCategory(item, options)
    })
}



/**
* Build a link for a menu item. This is used to create the link to the menu item's link - label
* 
* @param item - Menu item to build the link for
* @param options - Options for the link - label builder. Not used
* 
* @return { object } Link
*/
function buildALink(item, options) {
    return {
        href: item.href,
        type: "link",
        label: item.label
    }
}

/**
* Builds a topic based on the item. This is the entry point for the topic generation process. It takes care of creating the topic file if it doesn't exist and returning the basename of the topic
* 
* @param item - The item to build the topic for
* @param options - The options to use when building the topic file
* 
* @return { string } The basename of the topic that was created ( for use in paths and file names to avoid conflicts
*/
function buildTopic(item, options) {

    let parentPath = getSluggedPath(options.parentPath);
    let itemPath = getSluggedPath(item.path);
    let itemBasename = path.join(parentPath, itemPath, getItemSlug(item))

    // Create a topic file for the given item.
    if (!item.frozen)
    createTopicFile(item, itemBasename, options)

    return itemBasename.replace(/\\/g, '/')
}

/**
* Creates a topic file based on the item headings and sidebar_label. This is used to create the topic file when we're in the sidebar
* 
* @param item - The item that is being displayed
* @param itemBasename - The basename of the item ( for example " sidebar " )
* @param options - The options to use when rendering the item head
*/
function createTopicFile(item, itemBasename, options) {


    let template = `---
sidebar_label: {{{label}}}
---

{{#if title}}
# {{{title}}}
{{else}}
# {{{label}}}
{{/if}}
{{#if brief}}

{{{brief}}}
{{/if}}

{{{itemHeadings}}}

`
    let topicContent = render(template, {
        ...{ itemHeadings: buildHeadings(item.headings, options) },
        ...item,
    })

    let topicFilename = path.join(options.docs, itemBasename)
    topicFilename = setDefaultExtension(topicFilename, options.topicExtension)
    saveDocument(topicFilename, topicContent)
}

/**
* Builds headings for a tree of items. This is a recursive function that calls itself recursively for each item
* 
* @param items - The items to build the headings for
* @param options - The options to pass to the template. This is used to pass prefix and label
* @param level - The level of the headings to build
* 
* @return { string } The headings as a string with nested headings for each item in the tree rooted at
*/
function buildHeadings(items = [], options, level = 2) {

    return items
        .map(item => normalizeItem(item))
        .map(item => {

            let template = `{{{prefix}}} {{{label}}}

{{{itemHeadings}}}
`
            return render(template, {
                prefix: "#".repeat(level),
                label: item.label,
                itemHeadings: buildHeadings(item.items, options, level + 1)

            })
        })
        .join('')
}

/**
* Build a category object. This is used to build the sidebar items for each category. The items are passed to buildSidebarItems and will be merged with the default options.
* 
* @param item - The item to build the category for. Must have label and items
* @param options - Options to be passed to buildSidebarItems
* 
* @return { Object } The category object for the sidebar item with the label and items merged with the default options
*/
function buildCategory(item, options) {

    let category = {
        label: item.label,
        type: 'category',
        items: buildSidebarItems(item.items, { ...options, ...{ parentPath: [options.parentPath || '', item.path || ''].filter(p => !isEmpty(p)).join('/') } })
    }
    // Add link to category.
    if (item.generated_index) {
        category['link'] = {
            ...{
            type: 'generated-index',
            },
            ...{
                description: item.description || item.brief,
                title: item.title,
            }
            // description: item.description || item.brief || ''
        }
        // Set the slug of the item
        if (item.slug) {
            category['link'].slug = item.slug
        }
    } else {
        // Adds the item's meta data to the category. This is used to determine which kind of item we're dealing with

        if (item.doc) {
            category['link'] = {
                ...{
                type: 'doc',
                },
                ...{
                    description: item.description || item.brief,
                    title: item.title,
                }

            }
            // Set the slug of the item
            if (item.slug) {
                category['link'].id = item.slug
            }
        }
    }
    return category;
}

/**
* Returns the slug of an item. This is used to generate URLs for a list and the slug can be overridden by passing a slug or label property
* 
* @param item - The item to get the slug from
* 
* @return { string } The slug of the item as a string or undefined if no slug is set or label is
*/
function getItemSlug(item) {
    return slug(item.slug || item.label);
}

/**
* Takes a path and returns a slugified version of it. This is useful for generating URLs and other things that need to be slugged e. g.
* 
* @param pathItem - The path to slug. If it's a string it will be split into a string and slugged.
* 
* @return { string } The slugified version of the path or the original path if it wasn't a string
*/
function getSluggedPath(pathItem = '') {
    pathItem = (isString(pathItem)) ? pathItem.split('/') : pathItem;

    return pathItem.map(item => {
        // Set the item to be a string
        if (!isString(item)) {
            item = item;
        }
        return slug(item)
    }).join('/').replace(/^\//, '');

}

/**
* Normalizes an item to be used in the list. This is a helper function for ` normalizeList `.
* 
* @param item - The item to normalize. Can be a string or an object with ` label ` and / or ` items ` properties.
* 
* @return { Object } Normalized item to be used in the list. If ` item ` is a string it will be used as the label
*/
function normalizeItem(item) {
    item = (isString(item)) ? { label: item } : item;
    // Returns an object with label and items as label and label as label.
    if (isObject(item) && !Object.keys(item).includes('label')) {
        let label = Object.keys(item)[0]
        // Returns an item with the given label.
        if (isArray(item[label])) {
            item = {
                "label": label,
                "items": item[label].map(e => normalizeItem(e))
            }
        } else {
            item = {
                ...{ label },
                ...item[label],
            }
        }
    }
    item = isObject(item) ? { ...{ items: [], ...item, } } : item;

    return item;
}

/**
* Checks if an item is a topic. This is used to determine if we are dealing with a list of topics that is the result of a query or a topic with no sub - items
* 
* @param item - The item to check.
* 
* @return { boolean } True if the item is a topic false otherwise ( not a topic ) or null if it isn't
*/
function isTopic(item) {
    return item && item.items && isArray(item.items) && item.items.length === 0;
}